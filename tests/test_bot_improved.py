#!/usr/bin/env python3
"""–£–ª—É—á—à–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –±–æ—Ç–∞ —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""

import asyncio
import logging
import sys
import os
from datetime import datetime
from unittest.mock import AsyncMock, MagicMock

# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –≤ –ø—É—Ç—å –¥–ª—è –∏–º–ø–æ—Ä—Ç–æ–≤
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ImprovedMockMessage:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π Mock –æ–±—ä–µ–∫—Ç –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π Telegram."""
    
    def __init__(self, content_type="text", text=None, **kwargs):
        self.message_id = 12345
        self.date = datetime.now()
        self.content_type = content_type
        self.text = text
        self.from_user = MagicMock()
        self.from_user.id = 123456789
        self.from_user.first_name = "Test"
        self.from_user.last_name = "User"
        self.from_user.username = "testuser"
        self.chat = MagicMock()
        self.chat.id = 123456789
        self.chat.type = "private"
        self.bot = AsyncMock()
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–æ–ª—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
        for key, value in kwargs.items():
            setattr(self, key, value)
        
        # Mock –º–µ—Ç–æ–¥–æ–≤
        self.answer = AsyncMock()
        self.reply = AsyncMock()
        self.edit_text = AsyncMock()  # –î–æ–±–∞–≤–ª—è–µ–º edit_text –¥–ª—è callback queries


class ImprovedMockCallbackQuery:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π Mock –æ–±—ä–µ–∫—Ç –¥–ª—è callback query."""
    
    def __init__(self, data="test_callback", **kwargs):
        self.id = "callback_123"
        self.data = data
        self.from_user = MagicMock()
        self.from_user.id = 123456789
        self.from_user.first_name = "Test"
        self.from_user.last_name = "User"
        self.message = ImprovedMockMessage()
        self.message.edit_text = AsyncMock()  # –í–∞–∂–Ω–æ –¥–ª—è inline –∫–Ω–æ–ø–æ–∫
        self.bot = AsyncMock()
        
        for key, value in kwargs.items():
            setattr(self, key, value)
        
        self.answer = AsyncMock()


async def init_test_environment():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è —Å mock –∫—ç—à–µ–º."""
    
    print("üîß Initializing test environment...")
    
    try:
        # –°–æ–∑–¥–∞–µ–º mock –∫—ç—à –¥–ª—è —Ç–µ—Å—Ç–æ–≤
        from unittest.mock import patch
        
        mock_cache = MagicMock()
        mock_cache.get = AsyncMock(return_value=None)
        mock_cache.set = AsyncMock()
        mock_cache.invalidate = MagicMock()
        
        # –ü–∞—Ç—á–∏–º get_cache —á—Ç–æ–±—ã –≤–æ–∑–≤—Ä–∞—â–∞–ª –Ω–∞—à mock
        with patch('services.cache.get_cache', return_value=mock_cache):
            # –ü–∞—Ç—á–∏–º init_cache —á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞–ª
            with patch('services.cache.init_cache', return_value=mock_cache):
                print("‚úÖ Test environment initialized")
                return mock_cache
                
    except Exception as e:
        print(f"‚ö†Ô∏è Test environment setup issue: {e}")
        return None


async def test_handlers_with_cache():
    """–¢–µ—Å—Ç handlers —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π –∫—ç—à–∞."""
    
    print("üß™ Testing handlers with cache initialization...")
    
    mock_cache = await init_test_environment()
    
    try:
        # –ü–∞—Ç—á–∏–º –∫—ç—à –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –º–µ–Ω–µ–¥–∂–µ—Ä
        from unittest.mock import patch
        
        with patch('services.cache.get_cache', return_value=mock_cache):
            with patch('bot.context_manager.get_cache', return_value=mock_cache):
                from bot.handlers.common import CommonHandlers
                from bot.handlers.support import SupportHandler
                from bot.handlers.fallback import SmartFallbackHandler
                
                # –°–æ–∑–¥–∞–µ–º handlers
                common = CommonHandlers()
                support = SupportHandler()
                fallback = SmartFallbackHandler()
                
                # –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
                test_cases = [
                    {
                        "name": "Help handler",
                        "handler": common.help_and_support_handler,
                        "message": ImprovedMockMessage(text="üí¨ –ü–æ–º–æ—â—å")
                    },
                    {
                        "name": "Status handler", 
                        "handler": common.status_handler,
                        "message": ImprovedMockMessage(text="‚úÖ –ú–æ–π —Å—Ç–∞—Ç—É—Å")
                    },
                    {
                        "name": "Info handler",
                        "handler": common.show_info_menu,
                        "message": ImprovedMockMessage(text="üìä –û —Ä–æ–∑—ã–≥—Ä—ã—à–µ")
                    }
                ]
                
                for case in test_cases:
                    try:
                        await case["handler"](case["message"])
                        print(f"    ‚úÖ {case['name']} works")
                    except Exception as e:
                        print(f"    ‚ö†Ô∏è {case['name']}: {e}")
                
                print("‚úÖ Handler tests with cache completed")
                return True
                
    except Exception as e:
        print(f"‚ùå Handler cache test failed: {e}")
        return False


async def test_callback_handlers():
    """–¢–µ—Å—Ç callback handlers —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ mock –æ–±—ä–µ–∫—Ç–∞–º–∏."""
    
    print("üîò Testing callback handlers...")
    
    try:
        from bot.handlers.common import CommonHandlers
        from bot.handlers.support import SupportHandler
        
        common = CommonHandlers()
        support = SupportHandler()
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º callback queries
        callback_tests = [
            {
                "data": "info_rules",
                "handler": common.handle_info_callback,
                "description": "Info rules callback"
            },
            {
                "data": "info_prizes",
                "handler": common.handle_info_callback, 
                "description": "Info prizes callback"
            },
            {
                "data": "view_ticket_123",
                "handler": support.handle_view_ticket,
                "description": "View ticket callback"
            },
            {
                "data": "back_to_tickets_list",
                "handler": support.back_to_tickets_list,
                "description": "Back to tickets callback"
            }
        ]
        
        for test in callback_tests:
            try:
                callback = ImprovedMockCallbackQuery(data=test["data"])
                await test["handler"](callback)
                print(f"    ‚úÖ {test['description']} works")
            except Exception as e:
                print(f"    ‚ö†Ô∏è {test['description']}: {e}")
        
        print("‚úÖ Callback handler tests completed")
        return True
        
    except Exception as e:
        print(f"‚ùå Callback handler test failed: {e}")
        return False


async def test_error_resilience():
    """–¢–µ—Å—Ç —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ –∫ –æ—à–∏–±–∫–∞–º."""
    
    print("üõ°Ô∏è Testing error resilience...")
    
    test_scenarios = [
        {
            "name": "Message without from_user",
            "setup": lambda: ImprovedMockMessage(text="test", from_user=None)
        },
        {
            "name": "Message without chat",
            "setup": lambda: ImprovedMockMessage(text="test", chat=None)
        },
        {
            "name": "Callback without message",
            "setup": lambda: ImprovedMockCallbackQuery(data="test", message=None)
        },
        {
            "name": "Very long text",
            "setup": lambda: ImprovedMockMessage(text="A" * 5000)
        },
        {
            "name": "Unicode text",
            "setup": lambda: ImprovedMockMessage(text="üåçüî•üíØ –¢–µ—Å—Ç ‰∏≠Êñá ÿßŸÑÿπÿ±ÿ®Ÿäÿ© üöÄ")
        }
    ]
    
    results = []
    
    try:
        from bot.handlers.fallback import SmartFallbackHandler
        from aiogram.fsm.context import FSMContext
        
        fallback = SmartFallbackHandler()
        
        for scenario in test_scenarios:
            try:
                test_data = scenario["setup"]()
                
                # –°–æ–∑–¥–∞–µ–º mock state
                mock_state = MagicMock(spec=FSMContext)
                mock_state.get_data = AsyncMock(return_value={})
                mock_state.get_state = AsyncMock(return_value=None)
                
                # –¢–µ—Å—Ç–∏—Ä—É–µ–º fallback handler
                await fallback.handle_unexpected_text(test_data, mock_state)
                
                print(f"    ‚úÖ {scenario['name']} handled gracefully")
                results.append(True)
                
            except Exception as e:
                print(f"    ‚ö†Ô∏è {scenario['name']}: {e}")
                results.append(False)
        
        success_rate = sum(results) / len(results) if results else 0
        print(f"‚úÖ Error resilience: {success_rate:.1%} success rate")
        
        return success_rate > 0.6  # 60% tolerance
        
    except Exception as e:
        print(f"‚ùå Error resilience test failed: {e}")
        return False


async def test_media_handling_improved():
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ç–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ–¥–∏–∞."""
    
    print("üé• Testing improved media handling...")
    
    media_types = [
        {"type": "photo", "attr": "photo", "value": [{"file_id": "photo_123"}]},
        {"type": "voice", "attr": "voice", "value": {"file_id": "voice_123"}},
        {"type": "sticker", "attr": "sticker", "value": {"file_id": "sticker_123"}},
        {"type": "contact", "attr": "contact", "value": {"phone_number": "+123"}},
        {"type": "document", "attr": "document", "value": {"file_id": "doc_123"}}
    ]
    
    try:
        from bot.handlers.fallback import SmartFallbackHandler
        from aiogram.fsm.context import FSMContext
        
        fallback = SmartFallbackHandler()
        
        for media in media_types:
            try:
                # –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π mock –æ–±—ä–µ–∫—Ç –¥–ª—è –º–µ–¥–∏–∞
                kwargs = {media["attr"]: media["value"]}
                message = ImprovedMockMessage(content_type=media["type"], **kwargs)
                
                mock_state = MagicMock(spec=FSMContext)
                mock_state.get_data = AsyncMock(return_value={})
                mock_state.get_state = AsyncMock(return_value=None)
                
                # –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
                if media["type"] == "photo":
                    await fallback.handle_unexpected_photo(message, mock_state)
                elif media["type"] == "voice":
                    await fallback.handle_unexpected_voice(message, mock_state)
                elif media["type"] == "sticker":
                    await fallback.handle_unexpected_sticker(message, mock_state)
                elif media["type"] == "contact":
                    await fallback.handle_unexpected_contact(message, mock_state)
                else:
                    await fallback.handle_unexpected_text(message, mock_state)
                
                print(f"    ‚úÖ {media['type']} handled correctly")
                
            except Exception as e:
                print(f"    ‚ö†Ô∏è {media['type']}: {e}")
        
        print("‚úÖ Improved media handling tests completed")
        return True
        
    except Exception as e:
        print(f"‚ùå Media handling test failed: {e}")
        return False


async def main():
    """–ó–∞–ø—É—Å–∫ —É–ª—É—á—à–µ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤."""
    
    print("üöÄ Starting improved bot tests...\n")
    
    results = []
    
    # –¢–µ—Å—Ç handlers —Å –∫—ç—à–µ–º
    results.append(await test_handlers_with_cache())
    print()
    
    # –¢–µ—Å—Ç callback handlers
    results.append(await test_callback_handlers())
    print()
    
    # –¢–µ—Å—Ç —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ –∫ –æ—à–∏–±–∫–∞–º
    results.append(await test_error_resilience())
    print()
    
    # –¢–µ—Å—Ç —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ–¥–∏–∞
    results.append(await test_media_handling_improved())
    print()
    
    # –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    passed = sum(results)
    total = len(results)
    success_rate = (passed / total) * 100
    
    print(f"üìä Improved Test Results:")
    print(f"   Passed: {passed}/{total}")
    print(f"   Success Rate: {success_rate:.1f}%")
    
    if success_rate >= 75:
        print("üéâ EXCELLENT: All critical issues resolved!")
        print("‚úÖ Bot is robust and handles edge cases properly")
    elif success_rate >= 50:
        print("üëç GOOD: Major issues resolved, minor tweaks needed")
    else:
        print("‚ö†Ô∏è NEEDS WORK: Critical issues remain")
    
    return success_rate >= 75


if __name__ == "__main__":
    success = asyncio.run(main())
    exit(0 if success else 1)
